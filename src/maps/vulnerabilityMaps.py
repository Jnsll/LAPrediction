"""
    Provides functions to compute the vulnerability map of a simulation and the corresponding geographical site.
"""

import os
import numpy as np
import argparse
import flopy.utils.binaryfile as fpu
import math
import csv
import pandas as pd
import math
import flopy
from osgeo import gdal, osr
from helpers import helpers
import argparse

__author__ = "June Sallou"
__maintainer__ = "June Sallou"
__credits__ = ["June Sallou", "Alexandre Gauvain"]
__license__ = "MIT"
__version__ = "0.0.1"
__date__ = "06/30/2020"
__email__ = "june.benvegnu-sallou@univ-rennes1.fr"


dc = 0.3  # depth of threshold for the undeground vulnerable zone
alpha = float(1/3)


def get_model_size(coord):
    r_dem = "/DATA/These/Projects/modflops/docker-simulation/modflow" + "/data/MNT_TOPO_BATH_75m.tif"
    xmin = coord[0]
    xmax = coord[1]
    ymin = coord[2]
    ymax = coord[3]
    dem = gdal.Open(r_dem)
    dem_geot = dem.GetGeoTransform()
    dem_Xpos = np.ones((dem.RasterXSize))
    dem_Ypos = np.ones((dem.RasterYSize))
    for i in range(0, dem.RasterYSize):
        yp = dem_geot[3] + (dem_geot[5] * i)
        dem_Ypos[i] = yp
    for j in range(0, dem.RasterXSize):
        xp = dem_geot[0] + (dem_geot[1] * j)
        dem_Xpos[j] = xp
    ulX = (np.abs(dem_Xpos - xmin)).argmin()
    lrX = (np.abs(dem_Xpos - xmax)).argmin()
    ulY = (np.abs(dem_Ypos - ymax)).argmin()
    lrY = (np.abs(dem_Ypos - ymin)).argmin()
    clip_dem_x = dem_Xpos[ulX:lrX]
    clip_dem_y = dem_Ypos[ulY:lrY]
    return ulY, lrY, ulX, lrX, clip_dem_x, clip_dem_y




def compute_simple_vulnerability(site_number, chronicle, approx, rate, folder, ref, dc, alpha, timestep=1):

    model_name = helpers.get_model_name(site_number, chronicle, approx, rate, ref, perm=False)

    site_name = helpers.get_site_name_from_site_number(site_number)
    print(site_name)
    repo_simu = folder + site_name + "/" + model_name

    topoSimu = helpers.get_soil_surface_values_for_a_simulation(repo_simu, model_name)

    simuHds = fpu.HeadFile(repo_simu + '/' + model_name + '.hds')
    hds_data = simuHds.get_data(kstpkper=(0,0))

    nbrowtot = hds_data.shape[1]        
    nbcoltot = hds_data.shape[2]

    saturated_zones = np.zeros(shape=(nbrowtot,nbcoltot))
    vulnerable_zones = np.zeros(shape=(nbrowtot,nbcoltot))

    for nrow in range(nbrowtot):
        for ncol in range(nbcoltot):

            Zs = topoSimu[nrow][ncol]
            h = helpers.get_non_dry_cell_hds_value(hds_data, nrow, ncol, hds_data.shape[0])
            d =  Zs - h
            if d<= dc:
                saturated_zones[nrow][ncol] = 1 
            vulnerable_zones[nrow][ncol] = helpers.getWeightToSurface(Zs, h, dc, alpha)
            #print(helpers.getWeightToSurface(Zs, h, dc, alpha))


    np.save(repo_simu + "/SaturationZones_" + site_name + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) + ".npy", saturated_zones)
    np.save(repo_simu + "/VulnerabilityZones_" + site_name + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) + ".npy", vulnerable_zones)


def get_clip_dem(coord):
    r_dem = "/DATA/These/Projects/modflops/docker-simulation/modflow" + "/data/MNT_TOPO_BATH_75m.tif"
    ulY, lrY, ulX, lrX, clip_dem_x, clip_dem_y = get_model_size(coord)
    dem = gdal.Open(r_dem)
    dem_geot = dem.GetGeoTransform()
    dem_data = dem.GetRasterBand(1).ReadAsArray()
    clip_dem = dem_data[ulY:lrY, ulX:lrX]
    return dem_geot, clip_dem_x, clip_dem_y, clip_dem


def save_clip_dem(site_number, sat, vul, folder, chronicle, approx, rate, ref):
    sites = pd.read_csv("/DATA/These/Projects/modflops/docker-simulation/modflow" + "/data/study_sites.txt", sep=',', header=0, index_col=0)
    model_name = helpers.get_model_name(site_number, chronicle, approx, rate, ref, perm=False)
    site_name = helpers.get_site_name_from_site_number(site_number)
    repo_simu = folder + site_name + "/" + model_name

    coord = sites._get_values[site_number, 1:5]
    geot, geotx, geoty, demData = get_clip_dem(coord)
    drv = gdal.GetDriverByName("GTiff")
    if sat:
        ds = drv.Create(repo_simu + '/' + "SaturationZones_" + site_name + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) +  '_MNT.tif',
                    demData.shape[1], demData.shape[0], 1, gdal.GDT_Float32)
    if vul:
        ds = drv.Create(repo_simu + '/' + "VulnerabilityZones_" + site_name + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) +  '_MNT.tif',
                    demData.shape[1], demData.shape[0], 1, gdal.GDT_Float32)
    srs = osr.SpatialReference()
    srs.ImportFromEPSG(2154)
    ds.SetProjection(srs.ExportToWkt())
    gt = [geotx[0], geot[1], 0, geoty[1], 0, geot[5]]
    ds.SetGeoTransform(gt)
    if sat:
        values = np.load(repo_simu + "/SaturationZones_Site_" + str(site_number) + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) + ".npy")
    if vul:
        values = np.load(repo_simu + "/VulnerabilityZones_Site_" + str(site_number) + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) + ".npy")
    # for i in values:
    #     print(i)
    ds.GetRasterBand(1).WriteArray(values)


def compute_Ws_vulnerability(folder, site_number, chronicle, approx, rate, ref, time_step=1):
    '''
        Not for Stationary State Simulation !
    '''
    startTime = 0
    endTime = 15340
    # Get data for reference simulation
    # Path to repository 
    print("folder: ", folder)
    site_name = helpers.get_site_name_from_site_number(site_number)
    print("site_name: ", site_name)

    #topo_ref = 
    # Watertable altitude
    #ref_hds = fpu.HeadFile(repo_ref + '/' + ref_name + '.hds')
    #print("kstpkper: ", ref_hds.get_kstpkper()
    if ref:
        # Path to repository
        simu_name = helpers.get_model_name(site_number, chronicle, approx, rate, ref=True, perm=False)
        repo_simu = folder + site_name + simu_name 
        # Topographical altitude
        topoSimu = np.load(repo_simu + "/soil_surface_topo_"+ simu_name + ".npy")


    else:
        # Path to repository
        simu_name = helpers.get_model_name(site_number, chronicle, approx, rate, ref=False, perm=False)
        repo_simu = folder + site_name + simu_name
        # Topographical altitude
        topoSimu = helpers.get_soil_surface_values_for_a_simulation(repo_simu, simu_name)
    
    # Get heads values for simulation
    simu_hds = fpu.HeadFile(repo_simu + '/' + simu_name + '.hds')

    # Duration of simulated periods
    simu_times = simu_hds.get_times()
    init_head = simu_hds.get_data(kstpkper=(0,0))
    # Initialisation of error computing variables
    saturated_zones = np.zeros(shape=(init_head.shape[1], init_head.shape[2]))
    vulnerable_zones = np.zeros(shape=(init_head.shape[1], init_head.shape[2]))


    # For every day, we have to compare the reference and alternate simulations
    for day in range(startTime, endTime+1):
        print((day/endTime)*100, "%")

        # Compute the number of the simulated period of the alternate simulation for the considered day
        nbPeriod = 0
        while (simu_times[nbPeriod] < day+1) and (nbPeriod < len(simu_times)):
            nbPeriod += 1
        # print("nbPeriod : " + str(nbPeriod))

        # When the considered day match with the duration of the corresponding simulated period
        # We retrieve the value of the watertable altitude from the corresponding matrix
        if math.isclose(simu_times[nbPeriod], day+1, rel_tol=1e-3):
            altHeadSup = simu_hds.get_data(kstpkper=(time_step-1, nbPeriod))
            altHeadInf = altHeadSup
            duree = int(simu_times[nbPeriod])
            pas = 0
        # Otherwise, we have to interpolate the watertable altitude value for the considered day
        else:
            # The considered day is situated between the simulated period number 'nbPeriod-1' and number 'nbPeriod'
            altHeadSup = simu_hds.get_data(kstpkper=(time_step-1, nbPeriod))
            altHeadInf = simu_hds.get_data(kstpkper=(time_step-1, nbPeriod-1))
            duree = int(simu_times[nbPeriod] - simu_times[nbPeriod-1])
            pas = day - simu_times[nbPeriod-1]

        nbrowtot = altHeadInf.shape[1]
        nbcoltot = altHeadInf.shape[2]

        # mask to only get the data of the "equivalent watershed"
        mask_array, mask_ncol, mask_nrow = helpers.get_mask_data_for_a_site(site_number)
        if mask_nrow == nbrowtot:
            print("same number of rows")
        else:
            print("Not same number of rows!")
        if mask_ncol == nbcoltot:
            print("Same number of cols")
        else:
            print("Not same number of columns!")



        # We want to store the presence of cells part of a flood episode
        # We go through all the cells of the matrix representing the study site
        for nrow in range(nbrowtot):
            for ncol in range(nbcoltot):
                # only taking into account the values for the Equivalent Watershed (BVE)
                if np.isnan(mask_array[nrow][ncol]):
                    continue
                # Watertable altitude value for simulated period with duration lower than considered day
                ss = helpers.get_non_dry_cell_hds_value(
                    altHeadInf, nrow, ncol, altHeadInf.shape[0])
                # Watertable altitude value for simulated period with duration higher than considered day
                se = helpers.get_non_dry_cell_hds_value(
                    altHeadSup, nrow, ncol, altHeadInf.shape[0])
                ajoutSimu = (se - ss) / duree
                # Watertable altitude value for considered day being interpolated
                s = ss + (ajoutSimu * pas)

                # depth : topographical altitude  - watertable altitude
                d = topoSimu[nrow][ncol] - s
                if d<= dc:
                    saturated_zones[nrow][ncol] += 1

                # Watertable altitude value for simulated period for reference simulation
                WsSimu = helpers.getWeightToSurface(topoSimu[nrow][ncol], s, dc, alpha)

                vulnerable_zones[nrow][ncol] += WsSimu

    np.save(repo_simu + "/SaturationZones_Site_" + str(site_number) + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) + ".npy", saturated_zones)
    np.save(repo_simu + "/VulnerabilityZones_Site_" + str(site_number) + "_Chronicle_"+ str(chronicle) + "_Approx_" + str(approx) + "_Rate_" + str(rate) + ".npy", vulnerable_zones)




if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument("-chr", "--chronicle", type=int, required=True)
    parser.add_argument("-approx", "--approximation", type=int, required=False)
    parser.add_argument("-rate", "--rate", type=float, required=False)
    parser.add_argument("-site", "--sitenumber", type=int, required=True)
    parser.add_argument("-ref", "--ref", action='store_true')
    parser.add_argument("-step", "--step", type=int, required=False)
    parser.add_argument("-f", "--folder", type=str, required=True)
    parser.add_argument("-perm", "--permanent", type=int, required=False)
    parser.add_argument("-s", "--s", action='store_true')
    parser.add_argument("-v", "--v", action='store_true')


    args = parser.parse_args()

    approx = args.approximation
    chronicle = args.chronicle
    site_number = args.sitenumber
    rate = args.rate
    ref = args.ref
    folder = args.folder
    perm = args.permanent
    sat = args.s 
    vul = args.v 

    if sat or vul:
        save_clip_dem(site_number, sat, vul, folder, chronicle, approx, rate, ref)
    else:
        compute_Ws_vulnerability(folder, site_number, chronicle, approx, rate, ref)